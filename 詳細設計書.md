# GameBargain 詳細設計書

## 目次
1. [概要](#1-概要)
   - 1.1 [設計方針](#11-設計方針)
   - 1.2 [技術仕様詳細](#12-技術仕様詳細)
   - 1.3 [パフォーマンス要件](#13-パフォーマンス要件)

2. [アーキテクチャ設計](#2-アーキテクチャ設計)
   - 2.1 [レイヤー構成](#21-レイヤー構成)
   - 2.2 [モジュール依存関係](#22-モジュール依存関係)

3. [データベース詳細設計](#3-データベース詳細設計)
   - 3.1 [ER図](#31-er図)
   - 3.2 [テーブル詳細設計](#32-テーブル詳細設計)
     - 3.2.1 [usersテーブル](#321-usersテーブル)
     - 3.2.2 [gamesテーブル](#322-gamesテーブル)
     - 3.2.3 [pricesテーブル (1:N関係)](#323-pricesテーブル-1n関係)
     - 3.2.4 [user_favoritesテーブル](#324-user_favoritesテーブル)
     - 3.2.5 [price_historyテーブル](#325-price_historyテーブル)
     - 3.2.6 [notificationsテーブル](#326-notificationsテーブル)
   - 3.3 [データベース設定](#33-データベース設定)

4. [API詳細設計](#4-api詳細設計)
   - 4.1 [RESTful API エンドポイント](#41-restful-api-エンドポイント)
     - 4.1.1 [ゲーム関連API](#411-ゲーム関連api)
     - 4.1.2 [ユーザー関連API](#412-ユーザー関連api)
   - 4.2 [APIレスポンス型定義](#42-apiレスポンス型定義)
     - 4.2.1 [共通レスポンス型](#421-共通レスポンス型)
     - 4.2.2 [ゲーム関連レスポンス型](#422-ゲーム関連レスポンス型)

5. [機能詳細設計](#5-機能詳細設計)
   - 5.1 [F001: ゲーム検索機能](#51-f001-ゲーム検索機能)
     - 5.1.1 [処理フロー](#511-処理フロー)
     - 5.1.2 [クラス設計](#512-クラス設計)
     - 5.1.3 [入力値検証](#513-入力値検証)
   - 5.2 [F002: 価格比較機能](#52-f002-価格比較機能)
     - 5.2.1 [処理フロー](#521-処理フロー)
     - 5.2.2 [価格比較ロジック](#522-価格比較ロジック)
   - 5.3 [F003: Discord認証機能](#53-f003-discord認証機能)
     - 5.3.1 [OAuth2フロー](#531-oauth2フロー)
     - 5.3.2 [認証処理実装](#532-認証処理実装)
   - 5.4 [F004: お気に入り機能](#54-f004-お気に入り機能)
     - 5.4.1 [機能概要](#541-機能概要)
     - 5.4.2 [クラス設計](#542-クラス設計)
   - 5.5 [F006: 価格監視機能](#55-f006-価格監視機能)
     - 5.5.1 [機能概要](#551-機能概要)
     - 5.5.2 [価格変動検知ロジック](#552-価格変動検知ロジック)
     - 5.5.3 [バッチスケジュール設計](#553-バッチスケジュール設計)
   - 5.6 [通知システム設計](#56-通知システム設計)
     - 5.6.1 [通知サービス](#561-通知サービス)

6. [クラス設計](#6-クラス設計)
   - 6.1 [サービスクラス](#61-サービスクラス)
   - 6.2 [リポジトリクラス](#62-リポジトリクラス)
   - 6.3 [外部APIクライアント](#63-外部apiクライアント)

7. [シーケンス設計](#7-シーケンス設計)
   - 7.1 [ゲーム検索シーケンス](#71-ゲーム検索シーケンス)
   - 7.2 [Discord認証シーケンス](#72-discord認証シーケンス)
   - 7.3 [価格監視バッチシーケンス](#73-価格監視バッチシーケンス)

8. [エラーハンドリング設計](#8-エラーハンドリング設計)
   - 8.1 [例外クラス階層](#81-例外クラス階層)
   - 8.2 [エラー処理パターン](#82-エラー処理パターン)
   - 8.3 [ログ出力設計](#83-ログ出力設計)

9. [セキュリティ詳細設計](#9-セキュリティ詳細設計)
   - 9.1 [認証・認可](#91-認証認可)
   - 9.2 [CSRF対策](#92-csrf対策)
   - 9.3 [セッション管理](#93-セッション管理)
   - 9.4 [データ暗号化](#94-データ暗号化)

10. [パフォーマンス設計](#10-パフォーマンス設計)
    - 10.1 [キャッシュ戦略](#101-キャッシュ戦略)
    - 10.2 [データベース最適化](#102-データベース最適化)
    - 10.3 [API制限対応](#103-api制限対応)

11. [実装計画・優先度](#11-実装計画優先度)
    - 11.1 [開発フェーズ](#111-開発フェーズ)
    - 11.2 [技術的課題と対策](#112-技術的課題と対策)
    - 11.3 [運用・保守計画](#113-運用保守計画)
    - 11.4 [今後の拡張性](#114-今後の拡張性)

12. [技術仕様詳細](#12-技術仕様詳細)
    - 12.1 [環境変数設定](#121-環境変数設定)
    - 12.2 [依存関係](#122-依存関係)
    - 12.3 [Docker設定](#123-docker設定)

---

## 1. 概要

### 1.1 設計方針
- **単一責任原則**: 各クラス・モジュールは明確な責任を持つ
- **依存性注入**: テスタビリティと保守性を向上
- **レイヤードアーキテクチャ**: プレゼンテーション、ビジネス、データアクセスの分離
- **非同期処理**: Discord Bot、価格監視バッチの非同期実行

### 1.2 技術仕様詳細
| 項目 | 技術 | バージョン | 用途 |
|------|------|-----------|------|
| Python | 3.9+ | - | メイン言語 |
| Flask | 2.3+ | - | Webフレームワーク |
| Discord.py | 2.3+ | - | Discord Bot |
| SQLAlchemy | 2.0+ | - | ORM |
| Alembic | 1.11+ | - | DBマイグレーション |
| Flask-WTF | 1.1+ | - | フォーム・CSRF対策 |
| Requests | 2.31+ | - | HTTP クライアント |
| APScheduler | 3.10+ | - | スケジューラ |
| Authlib | 1.2+ | - | OAuth2クライアント |

### 1.3 パフォーマンス要件
| 項目 | 目標値 | 備考 |
|------|--------|------|
| 同時接続ユーザー数 | 100人 | 想定最大値 |
| API応答時間 | 95%ile 2秒以下 | 外部API依存を除く |
| DB接続プール | 10-20接続 | SQLAlchemy設定 |
| セッション有効期限 | 30日 | Discord認証標準 |
| キャッシュTTL | 5-60分 | データ種別により調整 |

---

## 2. アーキテクチャ設計

### 2.1 レイヤー構成
```
┌─────────────────────────────────────┐
│ Presentation Layer (Web UI)         │
│ - Flask Routes                      │
│ - Jinja2 Templates                  │
│ - Static Files                      │
├─────────────────────────────────────┤
│ Application Layer                   │
│ - Web Controllers                   │
│ - Discord Bot Commands              │
│ - API Endpoints                     │
├─────────────────────────────────────┤
│ Domain/Service Layer                │
│ - Game Service                      │
│ - Price Service                     │
│ - User Service                      │
│ - Notification Service              │
├─────────────────────────────────────┤
│ Infrastructure Layer                │
│ - External API Clients              │
│ - Database Access                   │
│ - Authentication                    │
└─────────────────────────────────────┘
```

### 2.2 モジュール依存関係
![モジュール依存関係図](モジュール依存関係図.drawio.png)

---

## 3. データベース詳細設計

### 3.1 ER図
![ER図](ER図.drawio.png)

### 3.2 テーブル詳細設計

#### 3.2.1 usersテーブル
```sql
CREATE TABLE users (
    user_id INTEGER PRIMARY KEY AUTOINCREMENT,
    discord_id VARCHAR(20) UNIQUE NOT NULL,
    username VARCHAR(100) NOT NULL,
    discriminator VARCHAR(4), -- Discord#0000形式のタグ
    avatar_url VARCHAR(255),
    email VARCHAR(255), -- Discord OAuth scope: email
    access_token TEXT, -- Discord OAuth token (暗号化)
    refresh_token TEXT, -- Discord refresh token (暗号化)
    token_expires_at TIMESTAMP,
    guild_ids JSON, -- 参加サーバーID配列
    is_active BOOLEAN DEFAULT TRUE,
    last_login_at TIMESTAMP,
    preferences JSON, -- ユーザー設定 (通知設定等)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- インデックス
CREATE INDEX idx_users_discord_id ON users(discord_id);
CREATE INDEX idx_users_is_active ON users(is_active);
CREATE INDEX idx_users_last_login ON users(last_login_at);
```

#### 3.2.2 gamesテーブル
```sql
CREATE TABLE games (
    game_id INTEGER PRIMARY KEY AUTOINCREMENT,
    title VARCHAR(200) NOT NULL,
    normalized_title VARCHAR(200) NOT NULL, -- 検索用正規化タイトル
    developer VARCHAR(100),
    publisher VARCHAR(100),
    steam_app_id VARCHAR(20) UNIQUE,
    epic_game_id VARCHAR(50),
    image_url VARCHAR(255),
    description TEXT,
    genres JSON, -- ジャンル配列
    release_date DATE,
    steam_rating DECIMAL(3,2), -- Steam評価 (0-100)
    metacritic_score INTEGER, -- Metacritic スコア
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- インデックス
CREATE INDEX idx_games_normalized_title ON games(normalized_title);
CREATE INDEX idx_games_steam_app_id ON games(steam_app_id);
CREATE INDEX idx_games_is_active ON games(is_active);
CREATE UNIQUE INDEX idx_games_steam_epic ON games(steam_app_id, epic_game_id);
```

#### 3.2.3 pricesテーブル (1:N関係)
```sql
CREATE TABLE prices (
    price_id INTEGER PRIMARY KEY AUTOINCREMENT,
    game_id INTEGER NOT NULL,
    store VARCHAR(20) NOT NULL, -- 'steam', 'epic'
    regular_price DECIMAL(10,2),
    sale_price DECIMAL(10,2),
    discount_rate INTEGER DEFAULT 0, -- 割引率 (0-100)
    currency VARCHAR(3) DEFAULT 'JPY',
    is_on_sale BOOLEAN DEFAULT FALSE,
    sale_start_date TIMESTAMP,
    sale_end_date TIMESTAMP,
    store_url VARCHAR(500), -- 購入ページURL
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (game_id) REFERENCES games(game_id) ON DELETE CASCADE
);

-- インデックス
CREATE INDEX idx_prices_game_store ON prices(game_id, store);
CREATE INDEX idx_prices_is_on_sale ON prices(is_on_sale);
CREATE INDEX idx_prices_created_at ON prices(created_at);

-- 【リレーション説明】
-- games (1) : prices (N) の関係
-- 1つのゲームに対して複数の価格情報が存在：
--
-- ◆ 現在価格（pricesテーブル）:
-- - 各ストアの「最新価格」のみを保持（最大2レコード/ゲーム）
-- - Steam: 最新の価格・セール情報
-- - Epic:  最新の価格・セール情報
-- 
-- ◆ 価格履歴（price_historyテーブル）:
-- - 価格変動の「履歴」を時系列で蓄積（多数レコード/ゲーム）
-- - 価格変動検知時に新規レコード追加
--
-- ◆ テーブル分離の理由:
-- - 頻繁アクセスする「現在価格」と、分析用の「履歴」を分離
-- - パフォーマンス向上（価格比較時は現在価格のみクエリ）
-- - データ量制御（現在価格は常に最新2レコードのみ）
```
```

#### 3.2.4 user_favoritesテーブル
```sql
CREATE TABLE user_favorites (
    favorite_id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    game_id INTEGER NOT NULL,
    notification_enabled BOOLEAN DEFAULT TRUE,
    price_threshold DECIMAL(10,2), -- 通知する価格閾値
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    FOREIGN KEY (game_id) REFERENCES games(game_id) ON DELETE CASCADE,
    UNIQUE(user_id, game_id)
);

-- インデックス
CREATE INDEX idx_user_favorites_user_id ON user_favorites(user_id);
CREATE INDEX idx_user_favorites_notification ON user_favorites(notification_enabled);
```

#### 3.2.5 price_historyテーブル
```sql
CREATE TABLE price_history (
    history_id INTEGER PRIMARY KEY AUTOINCREMENT,
    game_id INTEGER NOT NULL,
    store VARCHAR(20) NOT NULL,
    price DECIMAL(10,2),
    discount_rate INTEGER DEFAULT 0,
    change_type VARCHAR(20), -- 'price_increase', 'price_decrease', 'sale_start', 'sale_end'
    previous_price DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (game_id) REFERENCES games(game_id) ON DELETE CASCADE
);

-- インデックス
CREATE INDEX idx_price_history_game_store ON price_history(game_id, store);
CREATE INDEX idx_price_history_created_at ON price_history(created_at);

-- 【リレーション説明】
-- games (1) : price_history (N) の関係
-- 1つのゲームに対して複数の価格履歴レコードが存在：
-- 
-- ◆ 時系列による増加要因:
-- - Steam: 通常価格 ¥8000 → セール ¥4000 → 通常価格 ¥8000 (3レコード)
-- - Epic:  通常価格 ¥7500 → セール ¥3750 → 通常価格 ¥7500 (3レコード)
-- → 合計6レコードが同一ゲームに紐づく
--
-- ◆ 価格変動例（Cyberpunk 2077の場合）:
-- game_id=1, store='steam', price=8000, change_type='price_increase'  (2023-01-01)
-- game_id=1, store='steam', price=4000, change_type='sale_start'      (2023-06-15)
-- game_id=1, store='steam', price=8000, change_type='sale_end'        (2023-06-30)
-- game_id=1, store='epic',  price=7500, change_type='new_price'       (2023-02-01)
-- game_id=1, store='epic',  price=3750, change_type='sale_start'      (2023-07-01)
-- game_id=1, store='epic',  price=7500, change_type='sale_end'        (2023-07-15)
--
-- ◆ なぜ1:Nなのか:
-- - ストア数は2つだが、各ストアで価格変動のたびに履歴レコードが蓄積
-- - 価格変動は「変更があった時のみ」記録する設計
-- - 長期運用により1ゲームあたり数十〜数百の履歴レコードが想定される
```
```

#### 3.2.6 notificationsテーブル
```sql
CREATE TABLE notifications (
    notification_id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    game_id INTEGER,
    notification_type VARCHAR(50), -- 'price_drop', 'sale_start', 'sale_end', 'free_game'
    title VARCHAR(200),
    message TEXT,
    discord_channel_id VARCHAR(20),
    is_sent BOOLEAN DEFAULT FALSE,
    sent_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE SET NULL,
    FOREIGN KEY (game_id) REFERENCES games(game_id) ON DELETE SET NULL
);

-- インデックス
CREATE INDEX idx_notifications_user_id ON notifications(user_id);
CREATE INDEX idx_notifications_is_sent ON notifications(is_sent);
CREATE INDEX idx_notifications_created_at ON notifications(created_at);
```

### 3.3 データベース設定
```python
# config.py
import os
from datetime import timedelta

class Config:
    # Database
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'sqlite:///data/gamebargain.db'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_ENGINE_OPTIONS = {
        'pool_size': 10,
        'pool_recycle': 3600,
        'pool_pre_ping': True,
        'max_overflow': 20,
    }
    
    # Session (Discord認証標準)
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key'
    PERMANENT_SESSION_LIFETIME = timedelta(days=30)  # Discord認証標準期間
    SESSION_COOKIE_SECURE = True
    SESSION_COOKIE_HTTPONLY = True
    SESSION_COOKIE_SAMESITE = 'Lax'
    
    # Discord OAuth
    DISCORD_CLIENT_ID = os.environ.get('DISCORD_CLIENT_ID')
    DISCORD_CLIENT_SECRET = os.environ.get('DISCORD_CLIENT_SECRET')
    DISCORD_BOT_TOKEN = os.environ.get('DISCORD_BOT_TOKEN')
    DISCORD_REDIRECT_URI = os.environ.get('DISCORD_REDIRECT_URI')
    
    # External APIs
    STEAM_API_KEY = os.environ.get('STEAM_API_KEY')
    
    # Rate Limiting (100ユーザー想定)
    STEAM_API_RATE_LIMIT = 10  # requests per second
    EPIC_API_RATE_LIMIT = 5    # requests per second
    
    # Cache Settings
    CACHE_TYPE = "simple"  # メモリキャッシュ
    CACHE_DEFAULT_TIMEOUT = 300  # 5分
```

---

## 4. API詳細設計

### 4.1 RESTful API エンドポイント

#### 4.1.1 ゲーム関連API
```
GET /api/v1/games/search
  Query Parameters:
    - q: string (required) - 検索キーワード
    - limit: integer (optional, default=20) - 結果数制限
    - offset: integer (optional, default=0) - オフセット
    - store: string (optional) - ストアフィルター ('steam', 'epic', 'all')
    - genre: string (optional) - ジャンルフィルター
    - max_price: number (optional) - 最大価格フィルター
  Response: GameSearchResponse

GET /api/v1/games/{game_id}
  Path Parameters:
    - game_id: integer (required)
  Response: GameDetailResponse

GET /api/v1/games/{game_id}/prices
  Path Parameters:
    - game_id: integer (required)
  Query Parameters:
    - days: integer (optional, default=30) - 価格履歴期間
  Response: PriceHistoryResponse
```

#### 4.1.2 ユーザー関連API
```
GET /api/v1/user/profile
  Headers: Authorization: Bearer {token}
  Response: UserProfileResponse

PUT /api/v1/user/profile
  Headers: Authorization: Bearer {token}
  Request Body: UserProfileUpdateRequest
  Response: UserProfileResponse

GET /api/v1/user/favorites
  Headers: Authorization: Bearer {token}
  Response: UserFavoritesResponse

POST /api/v1/user/favorites
  Headers: Authorization: Bearer {token}
  Request Body: AddFavoriteRequest
  Response: FavoriteResponse

DELETE /api/v1/user/favorites/{game_id}
  Headers: Authorization: Bearer {token}
  Path Parameters:
    - game_id: integer (required)
  Response: SuccessResponse
```

### 4.2 APIレスポンス型定義

#### 4.2.1 共通レスポンス型
```python
from typing import Optional, List, Any
from pydantic import BaseModel
from datetime import datetime

class BaseResponse(BaseModel):
    success: bool
    message: Optional[str] = None
    timestamp: datetime

class ErrorResponse(BaseResponse):
    error_code: str
    details: Optional[dict] = None

class PaginatedResponse(BaseResponse):
    data: List[Any]
    pagination: dict  # {total, limit, offset, has_next, has_prev}
```

#### 4.2.2 ゲーム関連レスポンス型
```python
class PriceInfo(BaseModel):
    store: str
    regular_price: Optional[float]
    sale_price: Optional[float]
    discount_rate: int
    is_on_sale: bool
    store_url: str

class GameBasic(BaseModel):
    game_id: int
    title: str
    developer: Optional[str]
    image_url: Optional[str]
    current_prices: List[PriceInfo]
    lowest_price: Optional[PriceInfo]

class GameDetail(GameBasic):
    publisher: Optional[str]
    description: Optional[str]
    genres: List[str]
    release_date: Optional[str]
    steam_rating: Optional[float]
    metacritic_score: Optional[int]

class GameSearchResponse(PaginatedResponse):
    data: List[GameBasic]

class GameDetailResponse(BaseResponse):
    data: GameDetail
```

---

## 5. 機能詳細設計

### 5.1 F001: ゲーム検索機能

#### 5.1.1 処理フロー
![F001 ゲーム検索機能フロー](F001_ゲーム検索フロー.drawio.png)

#### 5.1.2 クラス設計
```python
class GameSearchService:
    def __init__(self, steam_client: SteamAPIClient, epic_client: EpicAPIClient, 
                 game_repository: GameRepository):
        self.steam_client = steam_client
        self.epic_client = epic_client
        self.game_repository = game_repository
    
    async def search_games(self, query: str, filters: SearchFilters) -> SearchResult:
        """ゲーム検索のメイン処理"""
        # 1. 入力値検証
        self._validate_search_query(query)
        
        # 2. ローカルDB検索
        local_results = await self._search_local_games(query, filters)
        
        # 3. 外部API検索（必要に応じて）
        if self._should_search_external(local_results, query):
            external_results = await self._search_external_apis(query, filters)
            # 4. 結果統合・重複除去
            merged_results = self._merge_results(local_results, external_results)
        else:
            merged_results = local_results
        
        # 5. 価格情報付与
        enriched_results = await self._enrich_with_prices(merged_results)
        
        # 6. ソート・フィルタリング
        final_results = self._apply_filters_and_sort(enriched_results, filters)
        
        return final_results
```

#### 5.1.3 入力値検証
```python
class SearchValidator:
    MIN_QUERY_LENGTH = 2
    MAX_QUERY_LENGTH = 100
    
    @staticmethod
    def validate_search_query(query: str) -> None:
        if not query or not query.strip():
            raise ValidationError("検索キーワードが入力されていません")
        
        if len(query.strip()) < SearchValidator.MIN_QUERY_LENGTH:
            raise ValidationError(f"検索キーワードは{SearchValidator.MIN_QUERY_LENGTH}文字以上で入力してください")
        
        if len(query.strip()) > SearchValidator.MAX_QUERY_LENGTH:
            raise ValidationError(f"検索キーワードは{SearchValidator.MAX_QUERY_LENGTH}文字以内で入力してください")
        
        # 特殊文字チェック
        if not re.match(r'^[a-zA-Z0-9\s\-\.\'\:]+$', query):
            raise ValidationError("使用できない文字が含まれています")
```

### 5.2 F002: 価格比較機能

#### 5.2.1 処理フロー
![F002 価格比較機能フロー](F002_価格比較フロー.drawio.png)

#### 5.2.2 価格比較ロジック
```python
class PriceComparisonService:
    def __init__(self, price_repository: PriceRepository):
        self.price_repository = price_repository
    
    async def compare_prices(self, game_id: int) -> PriceComparison:
        """価格比較処理"""
        # 1. 最新価格情報取得
        current_prices = await self.price_repository.get_latest_prices(game_id)
        
        # 2. 最安値判定
        cheapest_price = self._find_cheapest_price(current_prices)
        
        # 3. 割引率計算
        discount_info = self._calculate_discounts(current_prices)
        
        # 4. ストア比較結果作成
        comparison_result = PriceComparison(
            game_id=game_id,
            prices=current_prices,
            cheapest=cheapest_price,
            discount_info=discount_info,
            last_updated=datetime.utcnow()
        )
        
        return comparison_result
    
    def _find_cheapest_price(self, prices: List[PriceInfo]) -> Optional[PriceInfo]:
        """最安値を見つける"""
        if not prices:
            return None
        
        # セール価格優先、通常価格で比較
        def get_effective_price(price: PriceInfo) -> float:
            return price.sale_price if price.is_on_sale else price.regular_price
        
        return min(prices, key=get_effective_price)
```

### 5.3 F003: Discord認証機能

#### 5.3.1 OAuth2フロー
![F003 Discord認証フロー](F003_Discord認証フロー.drawio.png)

#### 5.3.2 認証処理実装
```python
from authlib.integrations.flask_client import OAuth
from flask import session, redirect, url_for, request
import secrets

class DiscordAuthService:
    def __init__(self, app, client_id: str, client_secret: str, redirect_uri: str):
        self.client_id = client_id
        self.client_secret = client_secret
        self.redirect_uri = redirect_uri
        
        # Authlib OAuth設定
        self.oauth = OAuth(app)
        self.discord = self.oauth.register(
            name='discord',
            client_id=client_id,
            client_secret=client_secret,
            server_metadata_url='https://discord.com/.well-known/openid_configuration',
            client_kwargs={'scope': 'identify email guilds'}
        )
    
    def get_authorization_url(self) -> str:
        """認証URL生成"""
        # CSRF対策のためstateを生成
        state = secrets.token_urlsafe(32)
        session['oauth_state'] = state
        
        return self.discord.authorize_redirect(
            redirect_uri=self.redirect_uri,
            state=state
        )
    
    async def handle_callback(self, code: str, state: str) -> DiscordUser:
        """認証コールバック処理"""
        # State検証
        if state != session.get('oauth_state'):
            raise AuthenticationError("Invalid state parameter")
        
        # トークン取得
        token = await self.discord.authorize_access_token()
        
        # ユーザー情報取得
        user_info = await self.discord.parse_id_token(token)
        guilds = await self._get_user_guilds(token['access_token'])
        
        # DiscordUserオブジェクト作成
        discord_user = DiscordUser(
            discord_id=user_info['sub'],
            username=user_info['preferred_username'],
            discriminator=user_info.get('discriminator'),
            avatar_url=self._get_avatar_url(user_info),
            email=user_info.get('email'),
            guilds=[guild['id'] for guild in guilds]
        )
        
        # セッション設定
        session['user_id'] = discord_user.discord_id
        session.permanent = True
        
        return discord_user
    
    def _get_avatar_url(self, user_info: dict) -> str:
        """アバターURL生成"""
        if not user_info.get('picture'):
            return f"https://cdn.discordapp.com/embed/avatars/{int(user_info.get('discriminator', '0')) % 5}.png"
        return user_info['picture']
    
    async def _get_user_guilds(self, access_token: str) -> list:
        """ユーザーのギルド情報取得"""
        import httpx
        
        headers = {'Authorization': f'Bearer {access_token}'}
        async with httpx.AsyncClient() as client:
            response = await client.get(
                'https://discord.com/api/users/@me/guilds',
                headers=headers
            )
            
        if response.status_code == 200:
            return response.json()
        return []

# Flask-Login用ユーザークラス
from flask_login import UserMixin

class User(UserMixin):
    def __init__(self, user_id: int, discord_id: str, username: str, 
                 avatar_url: str = None, is_active: bool = True):
        self.id = user_id
        self.discord_id = discord_id
        self.username = username
        self.avatar_url = avatar_url
        self._is_active = is_active
    
    def is_active(self):
        return self._is_active
    
    @staticmethod
    def get(user_id: int):
        """Flask-Login用ユーザー取得"""
        from models.user import UserRepository
        repo = UserRepository()
        return repo.get_by_id(user_id)
```

### 5.4 F004: お気に入り機能

#### 5.4.1 機能概要
- ユーザーがゲームをお気に入りに追加/削除
- 価格閾値設定による通知カスタマイズ
- Discord Bot通知との連携

#### 5.4.2 クラス設計
```python
class FavoriteService:
    def __init__(self, user_repository: UserRepository, game_repository: GameRepository,
                 favorite_repository: FavoriteRepository):
        self.user_repository = user_repository
        self.game_repository = game_repository
        self.favorite_repository = favorite_repository
    
    async def add_favorite(self, user_id: int, game_id: int, 
                          price_threshold: Optional[Decimal] = None) -> Favorite:
        """お気に入り追加"""
        # 1. ユーザー・ゲーム存在確認
        user = await self.user_repository.get_by_id(user_id)
        game = await self.game_repository.get_by_id(game_id)
        
        if not user or not game:
            raise ValidationError("ユーザーまたはゲームが見つかりません")
        
        # 2. 既存のお気に入りチェック
        existing = await self.favorite_repository.get_by_user_game(user_id, game_id)
        if existing:
            raise ValidationError("既にお気に入りに登録されています")
        
        # 3. お気に入り作成
        favorite = Favorite(
            user_id=user_id,
            game_id=game_id,
            notification_enabled=True,
            price_threshold=price_threshold
        )
        
        return await self.favorite_repository.save(favorite)
    
    async def remove_favorite(self, user_id: int, game_id: int) -> bool:
        """お気に入り削除"""
        favorite = await self.favorite_repository.get_by_user_game(user_id, game_id)
        if not favorite:
            raise ValidationError("お気に入りが見つかりません")
        
        return await self.favorite_repository.delete(favorite.favorite_id)
    
    async def get_user_favorites(self, user_id: int) -> List[GameWithFavorite]:
        """ユーザーのお気に入り一覧取得"""
        return await self.favorite_repository.get_user_favorites_with_games(user_id)
    
    async def update_notification_settings(self, user_id: int, game_id: int,
                                         notification_enabled: bool,
                                         price_threshold: Optional[Decimal] = None) -> Favorite:
        """通知設定更新"""
        favorite = await self.favorite_repository.get_by_user_game(user_id, game_id)
        if not favorite:
            raise ValidationError("お気に入りが見つかりません")
        
        favorite.notification_enabled = notification_enabled
        favorite.price_threshold = price_threshold
        
        return await self.favorite_repository.update(favorite)
```

### 5.5 F006: 価格監視機能

#### 5.5.1 機能概要
- 定期的な価格情報取得・更新
- 価格変動検知とお気に入りユーザーへの通知
- API制限を考慮した効率的なバッチ処理

#### 5.5.2 価格変動検知ロジック
```python
class PriceChangeDetector:
    def __init__(self, price_repository: PriceRepository, 
                 notification_service: NotificationService):
        self.price_repository = price_repository
        self.notification_service = notification_service
    
    async def detect_price_changes(self, game_id: int, new_prices: List[PriceInfo]) -> List[PriceChange]:
        """価格変動検知"""
        # 1. 現在の価格取得
        current_prices = await self.price_repository.get_latest_prices(game_id)
        current_by_store = {p.store: p for p in current_prices}
        
        changes = []
        
        for new_price in new_prices:
            current_price = current_by_store.get(new_price.store)
            
            if not current_price:
                # 新しいストア価格
                changes.append(PriceChange(
                    game_id=game_id,
                    store=new_price.store,
                    change_type='new_price',
                    new_price=new_price.effective_price,
                    previous_price=None
                ))
                continue
            
            # 価格変動チェック
            if new_price.effective_price != current_price.effective_price:
                change_type = self._determine_change_type(current_price, new_price)
                changes.append(PriceChange(
                    game_id=game_id,
                    store=new_price.store,
                    change_type=change_type,
                    new_price=new_price.effective_price,
                    previous_price=current_price.effective_price,
                    discount_rate=new_price.discount_rate
                ))
            
            # セール状態変更チェック
            if new_price.is_on_sale != current_price.is_on_sale:
                sale_change_type = 'sale_start' if new_price.is_on_sale else 'sale_end'
                changes.append(PriceChange(
                    game_id=game_id,
                    store=new_price.store,
                    change_type=sale_change_type,
                    new_price=new_price.effective_price,
                    previous_price=current_price.effective_price,
                    discount_rate=new_price.discount_rate
                ))
        
        return changes
    
    def _determine_change_type(self, current: PriceInfo, new: PriceInfo) -> str:
        """価格変動タイプ判定"""
        if new.effective_price < current.effective_price:
            return 'price_decrease'
        elif new.effective_price > current.effective_price:
            return 'price_increase'
        return 'price_unchanged'
    
    async def process_price_changes(self, changes: List[PriceChange]) -> None:
        """価格変動処理"""
        for change in changes:
            # 1. 価格履歴保存
            await self.price_repository.save_price_history(change)
            
            # 2. 通知対象ユーザー取得
            users_to_notify = await self._get_users_to_notify(change)
            
            # 3. 通知作成・送信
            for user in users_to_notify:
                await self.notification_service.create_price_notification(user, change)
    
    async def _get_users_to_notify(self, change: PriceChange) -> List[User]:
        """通知対象ユーザー取得"""
        # お気に入り登録 + 通知有効 + 価格閾値条件を満たすユーザー
        return await self.price_repository.get_users_for_price_notification(
            game_id=change.game_id,
            new_price=change.new_price,
            change_type=change.change_type
        )
```

#### 5.5.3 バッチスケジュール設計
```python
class PriceMonitoringScheduler:
    def __init__(self, price_service: PriceService):
        self.price_service = price_service
        self.scheduler = AsyncIOScheduler()
    
    def setup_schedules(self):
        """スケジュール設定"""
        # 毎時0分: 価格更新（お気に入りゲーム優先）
        self.scheduler.add_job(
            self.update_favorite_games_prices,
            CronTrigger(minute=0),
            id='update_favorite_prices',
            max_instances=1,
            misfire_grace_time=300  # 5分以内の遅延は許容
        )
        
        # 毎日3時: 全ゲーム価格更新
        self.scheduler.add_job(
            self.update_all_games_prices,
            CronTrigger(hour=3, minute=0),
            id='update_all_prices',
            max_instances=1,
            misfire_grace_time=1800  # 30分以内の遅延は許容
        )
        
        # 毎日9時: おすすめセール情報更新
        self.scheduler.add_job(
            self.update_recommended_sales,
            CronTrigger(hour=9, minute=0),
            id='update_recommendations',
            max_instances=1
        )
    
    async def update_favorite_games_prices(self):
        """お気に入りゲーム価格更新"""
        try:
            logger.info("Starting favorite games price update")
            
            # お気に入り登録されているゲーム一覧取得
            favorite_games = await self.price_service.get_favorite_games()
            
            success_count = 0
            error_count = 0
            
            for game in favorite_games:
                try:
                    await self.price_service.update_game_prices(game.game_id)
                    success_count += 1
                    
                    # レート制限対策: 各リクエスト間に待機
                    await asyncio.sleep(0.1)
                    
                except Exception as e:
                    logger.error(f"Failed to update prices for game {game.game_id}: {e}")
                    error_count += 1
            
            logger.info(f"Favorite games price update completed. Success: {success_count}, Error: {error_count}")
            
        except Exception as e:
            logger.error(f"Favorite games price update batch failed: {e}")
            raise
    
    async def update_all_games_prices(self):
        """全ゲーム価格更新（日次）"""
        try:
            logger.info("Starting all games price update")
            
            # アクティブなゲーム一覧取得（ページング）
            page_size = 50
            offset = 0
            total_processed = 0
            
            while True:
                games = await self.price_service.get_active_games(limit=page_size, offset=offset)
                
                if not games:
                    break
                
                for game in games:
                    try:
                        await self.price_service.update_game_prices(game.game_id)
                        total_processed += 1
                        
                        # レート制限対策
                        await asyncio.sleep(0.2)  # より保守的な間隔
                        
                    except Exception as e:
                        logger.error(f"Failed to update prices for game {game.game_id}: {e}")
                
                offset += page_size
                
                # 進捗ログ
                if total_processed % 100 == 0:
                    logger.info(f"Processed {total_processed} games")
            
            logger.info(f"All games price update completed. Total processed: {total_processed}")
            
        except Exception as e:
            logger.error(f"All games price update batch failed: {e}")
            raise
```

### 5.6 通知システム設計

#### 5.6.1 通知サービス
```python
class NotificationService:
    def __init__(self, discord_bot: DiscordBot, user_repository: UserRepository):
        self.discord_bot = discord_bot
        self.user_repository = user_repository
    
    async def create_price_notification(self, user: User, price_change: PriceChange) -> Notification:
        """価格変動通知作成"""
        game = await self.game_repository.get_by_id(price_change.game_id)
        
        # 通知メッセージ生成
        message = self._generate_price_notification_message(game, price_change)
        
        notification = Notification(
            user_id=user.user_id,
            game_id=price_change.game_id,
            notification_type=price_change.change_type,
            title=f"{game.title} - 価格変動",
            message=message,
            discord_channel_id=None  # DMまたは設定されたチャンネル
        )
        
        # 通知送信
        await self._send_discord_notification(user, notification)
        
        return notification
    
    def _generate_price_notification_message(self, game: Game, change: PriceChange) -> str:
        """通知メッセージ生成"""
        if change.change_type == 'sale_start':
            return (
                f"🎮 **セール開始！**\n"
                f"**{game.title}**\n"
                f"{change.store.title()}: ¥{change.previous_price:,.0f} → "
                f"¥{change.new_price:,.0f} ({change.discount_rate}%OFF)\n"
                f"💰 節約額: ¥{change.previous_price - change.new_price:,.0f}"
            )
        elif change.change_type == 'price_decrease':
            return (
                f"📉 **価格下落！**\n"
                f"**{game.title}**\n"
                f"{change.store.title()}: ¥{change.previous_price:,.0f} → "
                f"¥{change.new_price:,.0f}\n"
                f"💰 節約額: ¥{change.previous_price - change.new_price:,.0f}"
            )
        elif change.change_type == 'sale_end':
            return (
                f"⏰ **セール終了**\n"
                f"**{game.title}**\n"
                f"{change.store.title()}: ¥{change.previous_price:,.0f} → "
                f"¥{change.new_price:,.0f}\n"
                f"セールが終了しました。"
            )
        
        return f"{game.title}の価格が更新されました。"
    
    async def _send_discord_notification(self, user: User, notification: Notification) -> bool:
        """Discord通知送信"""
        try:
            # Discord ユーザーDM送信
            discord_user = await self.discord_bot.fetch_user(int(user.discord_id))
            
            embed = discord.Embed(
                title=notification.title,
                description=notification.message,
                color=0x00ff00 if 'セール' in notification.message else 0x0099ff
            )
            
            await discord_user.send(embed=embed)
            
            # 送信成功をDB記録
            notification.is_sent = True
            notification.sent_at = datetime.utcnow()
            await self.notification_repository.update(notification)
            
            return True
            
        except discord.NotFound:
            logger.warning(f"Discord user not found: {user.discord_id}")
            return False
        except discord.Forbidden:
            logger.warning(f"Cannot send DM to user: {user.discord_id}")
            return False
        except Exception as e:
            logger.error(f"Failed to send Discord notification: {e}")
            return False
```

---

## 11. 実装計画・優先度

### 11.1 開発フェーズ

#### Phase 1: 基盤機能 (1-2週間)
**目標**: 基本的なWebアプリケーション動作
- **F001**: ゲーム検索機能 (Steam APIメイン)
- **F002**: 価格比較機能 (基本版)
- **F003**: Discord認証機能
- データベース設計・マイグレーション
- 基本的なWeb UI

**完了条件**: 
- ユーザーがDiscordでログイン可能
- ゲーム検索・価格表示が動作
- 基本的な画面遷移が完成

#### Phase 2: ユーザー機能 (1週間)
**目標**: ユーザー個別機能の実装
- **F004**: お気に入り機能
- ユーザーページ・設定画面
- セッション管理の安定化

**完了条件**:
- お気に入り登録・削除が動作
- ユーザー設定の保存・読み込み
- 認証状態の維持

#### Phase 3: Discord Bot (1-2週間)
**目標**: Discord Bot機能の実装
- **F005**: Discord Bot基本機能
- ゲーム検索・価格確認コマンド
- WebアプリとBotの統合

**完了条件**:
- Discord Bot がコマンドに応答
- WebアプリとDB・ロジック共有
- Bot招待・設定が可能

#### Phase 4: 価格監視・通知 (1-2週間)
**目標**: 自動化・通知機能の実装
- **F006**: 価格監視バッチ機能
- 通知システム (Discord DM)
- Epic Games API対応

**完了条件**:
- 価格変動の自動検知
- お気に入りゲームの通知
- 安定したバッチ処理

#### Phase 5: 品質向上・運用準備 (1週間)
**目標**: 本番運用可能な品質
- エラーハンドリング強化
- パフォーマンス最適化
- ログ・監視機能
- デプロイメント準備

### 11.2 技術的課題と対策

#### 高優先度課題
1. **API制限対応**
   - 課題: Steam/Epic APIのレート制限
   - 対策: 適切な間隔制御、キャッシュ活用、フォールバック処理

2. **価格データ品質**
   - 課題: 外部APIデータの不整合・欠損
   - 対策: データ検証ロジック、複数ソース照合、手動補正機能

3. **スケーラビリティ**
   - 課題: ユーザー増加時のパフォーマンス
   - 対策: 効率的なDB設計、キャッシュ戦略、バッチ処理最適化

#### 中優先度課題
1. **Discord Bot安定性**
   - 課題: Bot接続切断、コマンド応答性
   - 対策: 再接続ロジック、タイムアウト設定、エラー通知

2. **認証セキュリティ**
   - 課題: OAuth トークン管理、セッション安全性
   - 対策: トークン暗号化、適切な有効期限、CSRF対策

### 11.3 運用・保守計画

#### 定期メンテナンス
- **日次**: バッチ処理ログ確認、API成功率確認
- **週次**: データベース整合性チェック、パフォーマンス分析
- **月次**: 外部API仕様変更確認、セキュリティ更新

#### 監視項目
1. **システム稼働率**: 95%以上維持
2. **API応答時間**: 95%ile 2秒以下
3. **バッチ処理成功率**: 90%以上
4. **通知送信成功率**: 95%以上

#### 障害対応
1. **外部API障害**: キャッシュデータで継続、復旧後自動同期
2. **Discord API障害**: 通知を一時保留、復旧後一括送信
3. **データベース障害**: 読み取り専用モードで継続、アラート送信

### 11.4 今後の拡張性

#### 短期的拡張 (3-6ヶ月)
- **価格履歴グラフ**: Chart.js による視覚化
- **ジャンル別フィルター**: 詳細な検索条件
- **ウィッシュリスト機能**: 価格目標設定

#### 中期的拡張 (6-12ヶ月)
- **モバイルアプリ**: React Native/Flutter
- **他ストア対応**: PlayStation Store, Nintendo eShop
- **ユーザーレビュー**: コミュニティ機能

#### 長期的展望 (1年以上)
- **AI価格予測**: 機械学習による価格変動予測
- **API提供**: 他サービスでの利用
- **収益化**: アフィリエイト、プレミアム機能

---

## 12. 技術仕様詳細

### 12.1 環境変数設定
```bash
# .env ファイル例
# Discord設定
DISCORD_CLIENT_ID=your_client_id
DISCORD_CLIENT_SECRET=your_client_secret
DISCORD_BOT_TOKEN=your_bot_token
DISCORD_REDIRECT_URI=http://localhost:5000/auth/callback

# 外部API
STEAM_API_KEY=your_steam_api_key

# データベース
DATABASE_URL=sqlite:///data/gamebargain.db

# セキュリティ
SECRET_KEY=your-secret-key-32-chars-minimum
ENCRYPTION_KEY=your-encryption-key-for-tokens

# 環境設定
FLASK_ENV=development
LOG_LEVEL=DEBUG
```

### 12.2 依存関係 (requirements.txt)
```
Flask==2.3.3
SQLAlchemy==2.0.21
Alembic==1.11.3
discord.py==2.3.2
authlib==1.2.1
requests==2.31.0
APScheduler==3.10.4
Flask-WTF==1.1.1
python-dotenv==1.0.0
cryptography==41.0.4
Jinja2==3.1.2
click==8.1.7
```

### 12.3 Docker設定
```dockerfile
# Dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 5000

CMD ["python", "app.py"]
```

```yaml
# docker-compose.yml
version: '3.8'
services:
  gamebargain:
    build: .
    ports:
      - "5000:5000"
    volumes:
      - ./data:/app/data
    environment:
      - FLASK_ENV=production
    restart: unless-stopped
```